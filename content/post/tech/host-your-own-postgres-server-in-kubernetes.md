---
title: "How to set up Postgres server for stating environment on Kubernetes"
date: "2020-04-04T00:22:02+07:00"
author: "Nhat Pham"
description : ""
draft: false
categories : ["tech"]
type : "post"
featured : "undraw_server_status.png"
featuredalt : "post 1"
featuredpath : "date"
---
![::img-medium](https://www.mvps.net/docs/wp-content/uploads/2019/06/kubernetes.png)

In software development, the staging environment (stage) is a near replica of a production environment for software testing. It requires a copy of the same configurations of hardware, servers, caching and database.
The fact that if your project budget is quite good enough, you can choose a cloud service to host your databases such as Amazon Web Service(AWS), Microsoft Azure or Google Cloud.

What if your app has been not released and it's been in the development process or even your client doesn't want to spend too much cost in this stage?

This article will walk you through step by step to host your own PostgreSQL database in your virtual machine without spending money to SaaS.

{{% notice info %}}
This lab uses Kubernetes cluster hosted on [**Azure cloud**](https://azure.microsoft.com/en-us/), therefore some configurations might be different on your machine.
{{% /notice %}}

## Prerequisite
- Working Kubernetes Cluster
- Basic understanding of Docker

You can provision the Kubernetes cluster on any public cloud provider like AWS, Azure or Google cloud, etc.
To create your own PostgreSQL server on Kubernetes, we need the folowwing steps below:
## Manifest Preparation
### Creating Configmaps for PostgreSQL configuration
We firstly defined Postgres information which you will use it to connect later

File: **configmap-postgres.yml**
```yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-config
  labels:
    app: postgres
data:
  POSTGRES_DB: mydb
  POSTGRES_USER: vincentpham
  POSTGRES_PASSWORD: vincentpham
```

Run kubectl command to create the Configmaps object:
```bash
kubectl apply -f configmap-postgres.yml
```

{{% notice note %}}
You can change the favorite database nane, user and password, **mydb** and **vincentpham** is not a mandatory.
{{% /notice %}}

### Creating Persistent Volume and Persistent Volume Claim
As you all know, all the data which is generated by the container will be lost after a termination of the container instance. To keep the data, we must use Kubernetes persistent volume and persistent volumne claim resource to store data on persistent storages.  

File: **persistent-storage-volume.yml**
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: postgres-pv-volume
  labels:
    app: postgres
    type: local
spec:
  storageClassName: standard
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pv-claim
  labels:
    app: postgres
spec:
  storageClassName: standard
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi
```
Run kubectl command to create the PersistentVolume and PersistentVolumeClaim Object:
```bash
kubectl apply -f persistent-storage-volume.yml
```

### Creating Deployment
PostgreSQL deployment uses PostgresQL image version 10.12. It's using the environtment variables from the configmap like username, password, database name to to create postgres instance. It also mounts the volume created from the persistent volumes and claims to make PostgreSQL containerâ€™s data persists.  

File: **deployment_postgres.yml**
```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name:  postgres-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app:  postgres
    spec:
      containers:
        - name:  postgres
          image:  postgres:10.4
          imagePullPolicy: "IfNotPresent"
          ports:
            - containerPort:  5432
          envFrom:
            - configMapRef:
                name: postgres-config
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: postgredb
            # - mountPath: /var/lib/postgresql/postgres-config
            #   name: postgres-conf
            # - mountPath: /var/lib/postgresql/pghba-config
            #   name: pghba-conf
      volumes:
        - name: postgredb
          persistentVolumeClaim:
            claimName: postgres-pv-claim
```

### Creating Service
File: **service_postgres.yml**
```yml
apiVersion: v1
kind: Service
metadata:
  name:  postgres-staging
  namespace: staging
  labels:
    app: postgres
spec:
  type:  LoadBalancer
  selector:
    app:  postgres
  ports:
  - name:  postgres-node
    port:  5432
    targetPort:  5432
    nodePort: 31516
```

Run `kubectl get all` command to see all resources
```bash                                                                                             
NAME                                       READY   STATUS    RESTARTS   AGE
pod/postgres-deployment-597c8bdbd9-w7tld   1/1     Running   0          3m5s

NAME                       TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
service/kubernetes         ClusterIP      10.96.0.1      <none>        443/TCP          3m35s
service/postgres-staging   LoadBalancer   10.98.245.22   <pending>     5432:31516/TCP   2m57s

NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/postgres-deployment   1/1     1            1           3m5s

NAME                                             DESIRED   CURRENT   READY   AGE
replicaset.apps/postgres-deployment-597c8bdbd9   1         1         1       3m5s
```
Let's take a look at the external-ip column in the service area, it has a pending ip address which you can access your database from the world along with the port.
if you're hosting your Kubernetes cluster on the cloud, you should see the following result:
```bash
NAME                            TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE
service/postgres-staging        LoadBalancer   10.0.250.38    51.124.xxx.xxx   5432:31516/TCP   28d
```
you can add this IP to your DNS table so that you can access the postgres instance via a better url format. Here is the result, huraaaa :))
![some alt text:inline](https://i.imgur.com/pz5IV8Z.png)
Thank for watching to the end. Here is the [completed resources](https://github.com/vincentpham13/postgres-kubernetes)